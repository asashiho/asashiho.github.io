<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=ja-jp lang=ja-jp><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.64.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Kubernetes上で動くアプリのバージョンアップ、裏側でなにがおこっているのか &#183; ASA Blog</title><meta name=description content="KubernetesのDeploymentリソースのしくみの説明です。"><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link type=text/css rel=stylesheet href=https://use.fontawesome.com/releases/v5.0.6/css/all.css><link type=text/css rel=stylesheet href=https://aakira.app/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css integrity=sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0 crossorigin=anonymous><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css integrity=sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js integrity=sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js integrity=sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF crossorigin=anonymous onload=renderMathInElement(document.body);></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},{left:"\\(",right:"\\)",display:false}]});});</script><meta property="og:site_name" content="ASA Blog"><meta property="og:title" content="Kubernetes上で動くアプリのバージョンアップ、裏側でなにがおこっているのか"><meta property="og:url" content="https://asashiho.github.io/kubernetes-deployment/kubernetes-deployment/"><meta property="og:type" content="article"><meta name=twitter:card content="summary"><meta name=twitter:site content="@_dr_asa"><meta name=twitter:creator content="@_dr_asa"><meta property="twitter:title" content="Kubernetes上で動くアプリのバージョンアップ、裏側でなにがおこっているのか"><meta property="og:description" content="KubernetesのDeploymentリソースのしくみの説明です。"><meta property="twitter:description" content="KubernetesのDeploymentリソースのしくみの説明です。"><meta property="og:image" content="https://asashiho.github.io/thumbnails/prof.jpg"><meta property="og:image:url" content="https://asashiho.github.io/thumbnails/prof.jpg"></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://asashiho.github.io/><h1>ASA Blog</h1></a><p class=lead>enjoy a laid-back life</p></div><nav><ul class=sidebar-nav><li><a href=https://asashiho.github.io/>Home</a></li><li><a href=https://github.com/asashiho/>GitHub</a></li><li><a href=https://www.linkedin.com/in/shiho-asa/>LinkedIn</a></li></ul></nav><p>&copy; 2021. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Kubernetes上で動くアプリのバージョンアップ、裏側でなにがおこっているのか</h1><time datetime=2021-10-10T00:00:00Z class=post-date>Sun, Oct 10, 2021</time>
<a href="http://twitter.com/intent/tweet?url=https%3a%2f%2fasashiho.github.io%2fkubernetes-deployment%2fkubernetes-deployment%2f&text=Kubernetes%e4%b8%8a%e3%81%a7%e5%8b%95%e3%81%8f%e3%82%a2%e3%83%97%e3%83%aa%e3%81%ae%e3%83%90%e3%83%bc%e3%82%b8%e3%83%a7%e3%83%b3%e3%82%a2%e3%83%83%e3%83%97%e3%80%81%e8%a3%8f%e5%81%b4%e3%81%a7%e3%81%aa%e3%81%ab%e3%81%8c%e3%81%8a%e3%81%93%e3%81%a3%e3%81%a6%e3%81%84%e3%82%8b%e3%81%ae%e3%81%8b" target=_blank title=Tweet><i class="fab fa-twitter"></i></a>&ensp;
<a href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fasashiho.github.io%2fkubernetes-deployment%2fkubernetes-deployment%2f&t=Kubernetes%e4%b8%8a%e3%81%a7%e5%8b%95%e3%81%8f%e3%82%a2%e3%83%97%e3%83%aa%e3%81%ae%e3%83%90%e3%83%bc%e3%82%b8%e3%83%a7%e3%83%b3%e3%82%a2%e3%83%83%e3%83%97%e3%80%81%e8%a3%8f%e5%81%b4%e3%81%a7%e3%81%aa%e3%81%ab%e3%81%8c%e3%81%8a%e3%81%93%e3%81%a3%e3%81%a6%e3%81%84%e3%82%8b%e3%81%ae%e3%81%8b" target=_blank title=Facebook><i class="fab fa-facebook"></i></a>&ensp;
<a href="https://plus.google.com/share?url=https%3a%2f%2fasashiho.github.io%2fkubernetes-deployment%2fkubernetes-deployment%2f" target=_blank title=google+><i class="fab fa-google-plus"></i></a><hr><p>最近業務でお手伝いさせていただく案件のなかでも、Java on Kubernetesなパターンが増えてきています。Kubernetesに限らずクラウドのマネージドPaaSで動かすにはアプリケーション側でもクラウドネイティブを考慮した実装が必要になり、特に耐障害性や回復性などを意識した実装が大事になってきます。</p><p>アプリケーションのリリース方式も、オンプレでのWeb3層システムとは考え方が異なる部分やKubernetesのしくみを正しく理解しておく必要があるので、あらためて整理したいと思います。</p><hr><h1 id=アプリのバージョンアップ>アプリのバージョンアップ</h1><p>アプリケーション開発の世界では、1度リリース完了したらそれで終わりではなく、新機能追加やバグ修正などによりバージョンアップが行われます。特にビジネス要件の変更が頻繁なケースでは、小さな単位でアプリケーションの機能追加/修正し、短いタイミングでリリースする手法が使われています。</p><p>しかしながら、アプリケーションのバージョンアップには危険を伴います。ちょっとした設定ミスによりシステムエラーをおこし、場合によってはサービス停止に至ることもあるでしょう。したがって、テスト済みの安全なものを、なるべく迅速に本番環境にデプロイできるしくみを整えることが大事です。</p><p>アプリケーションを本番環境にデプロイする手法はいくつかありますが、代表的なものは次の2つです。</p><h4 id=ローリングアップデート>ローリングアップデート</h4><p>アプリケーションをバージョンアップする際に、まとめて一気に変更するのではなく、稼動状態のまま少しずつ順番に更新する手法です。同じアプリケーションが複数並列に動いている場合に徐々に入れ替えていくので、バージョンアップ中は新旧のアプリケーションが混在することになります。そのためアプリケーションがローリングアップデートに対応している必要があります。</p><p><img src=../docs/images/rolling-update.png alt=rolling-update></p><h4 id=ブルーグリーンデプロイメント>ブルー/グリーンデプロイメント</h4><p>バージョンの異なる新旧2つのアプリケーションを同時に起動させておき、ネットワークの設定変更で変更する方法です。ブルー（旧）とグリーン（新）を切り替えることから、ブルー/グリーンデプロイメントと呼ばれます。
ブルーが本番としてサービス提供しているときには、グリーンは待機している状態となります。新機能は、待機系であるグリーン側に追加して、こちらで事前テストを実施します。そしてテストをクリアしたことを確認したうえでグリーンを本番に切り替えます。この方式はもし切り替えたグリーンのアプリケーションで障害があったときに、即座にブルーに切り戻せるというメリットがあります。</p><p><img src=../docs/images/bluegreen.png alt=bluegreen></p><p>このほかにも、一部の利用者にのみ新機能を提供し、問題がないことを確認してから全ユーザに大規模展開するカナリアリリースなどもあります。</p><h1 id=deploymentを使ったアプリのバージョンアップ>Deploymentを使ったアプリのバージョンアップ</h1><p>Kubernetesには、安全にアプリをアップデートするしくみが備わっていて「Deployment」と呼ばれています。</p><p>この、Deploymentリソースには、大きく分けて次の2つのアップデートの処理方式があります。これは、マニフェストファイルのDeploymentの<code>spec</code>-<code>strategy</code>-<code>type</code>で設定し、デフォルトは<code>RollingUpdate</code>です。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>spec</span>:
  <span style=color:#66d9ef>strategy</span>:
    <span style=color:#66d9ef>type</span>: Recreate
</code></pre></div><ul><li><p>Recrate
いったん古いPodをすべて停止し、新しいPodを再作成する方式です。シンプルで高速に動きますが、ダウンタイムが発生します。開発環境やダウンタイムが許容できるシステムなどで使います。</p></li><li><p>RollingUpdate
クラスターで動くPodを少しずつアップデートしていく方式です。古いPodが動いている状態で、新しいPodを起動し、新しいPodの起動が確認出来たら古いPodを停止するという動きをします。一時的に新旧のバージョンが混在するので処理方法は複雑になりますが、ダウンタイムなしで移行できるのが特徴です。本番環境ではこちらを採用するのが良いでしょう。</p></li></ul><p><img src=../docs/images/kubernetes-update.png alt=kubernetes-update></p><h2 id=deploymentによるrollingupdate>DeploymentによるRollingUpdate</h2><p>ここではDeploymentリソースのデフォルトになっているRollingUpdateによるバージョンアップの挙動をみていきます。</p><h4 id=ロールアウト>ロールアウト</h4><p>ロールアウトとは、アプリケーションをクラスター内にデプロイし、サービスを稼働させることです。</p><p>ここで、次のDeploymentを作成します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>apiVersion</span>: apps/v1
<span style=color:#66d9ef>kind</span>: Deployment
<span style=color:#66d9ef>metadata</span>:
  <span style=color:#66d9ef>labels</span>:
    <span style=color:#66d9ef>app</span>: front
  <span style=color:#66d9ef>name</span>: front
<span style=color:#66d9ef>spec</span>:
  <span style=color:#66d9ef>replicas</span>: <span style=color:#ae81ff>3</span>
  <span style=color:#66d9ef>strategy</span>:
    <span style=color:#66d9ef>type</span>: RollingUpdate
  <span style=color:#66d9ef>selector</span>:
    <span style=color:#66d9ef>matchLabels</span>:
      <span style=color:#66d9ef>app</span>: front
  <span style=color:#66d9ef>template</span>:
    <span style=color:#66d9ef>metadata</span>:
      <span style=color:#66d9ef>labels</span>:
        <span style=color:#66d9ef>app</span>: front
    <span style=color:#66d9ef>spec</span>:
      <span style=color:#66d9ef>containers</span>:
        - <span style=color:#66d9ef>image</span>: xxx/frontend:v1<span style=color:#ae81ff>.0</span><span style=color:#ae81ff>.0</span>
          <span style=color:#66d9ef>name</span>: front
</code></pre></div><p>次のコマンドを実行すると、クラスタに<code>frontend:v1.0.0</code>がデプロイされます。</p><pre><code>kubectl apply -f deployment.yaml
</code></pre><p>ロールアウトの状況を確認するは<code>kubectl rollout status</code>コマンド、詳細を確認するには<code>kubectl describe deploy</code>コマンドを実行します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl rollout status deploy front
Waiting <span style=color:#66d9ef>for</span> deployment <span style=color:#e6db74>&#34;front&#34;</span> rollout to finish: <span style=color:#ae81ff>0</span> of <span style=color:#ae81ff>3</span> updated replicas are available...
Waiting <span style=color:#66d9ef>for</span> deployment <span style=color:#e6db74>&#34;front&#34;</span> rollout to finish: <span style=color:#ae81ff>1</span> of <span style=color:#ae81ff>3</span> updated replicas are available...
Waiting <span style=color:#66d9ef>for</span> deployment <span style=color:#e6db74>&#34;front&#34;</span> rollout to finish: <span style=color:#ae81ff>2</span> of <span style=color:#ae81ff>3</span> updated replicas are available...
deployment <span style=color:#e6db74>&#34;front&#34;</span> successfully rolled out
</code></pre></div><p>ロールアウトできているのが分かります。次に詳細をみてみます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl describe deploy front
</code></pre></div><p>するとDeploymentの詳細が表示されます。<code>Annotations</code>フィールドに<code>revision=1</code>が自動で付加されているのがわかりますが、この値は、ローリングアップデートのたびに増えていきます。</p><pre><code>Name:                   front
Namespace:              default
CreationTimestamp:      Sun, 10 Oct 2021 09:02:34 +0900
Labels:                 app=front
Annotations:            deployment.kubernetes.io/revision: 1
</code></pre><p>以下のフィールドをみると、ローリングアップデートの状況が確認できます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>Selector:               app<span style=color:#f92672>=</span>front
Replicas:               <span style=color:#ae81ff>3</span> desired | <span style=color:#ae81ff>3</span> updated | <span style=color:#ae81ff>3</span> total | <span style=color:#ae81ff>3</span> available | <span style=color:#ae81ff>0</span> unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        <span style=color:#ae81ff>0</span>
RollingUpdateStrategy:  10% max unavailable, 30% max surge
</code></pre></div><p>Deploymentの状態は<code>Conditions</code>フィールド、ログは<code>Events</code>フィールドで確認できます。Deploymentが切り替えた新旧のReplicaSetはそれぞれ<code>OldReplicaSets</code>と<code>NewReplicaSet</code>フィールドで確認できます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable

Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  39s   deployment-controller  Scaled up replica set front-7876d7bd66 to <span style=color:#ae81ff>3</span>
</code></pre></div><p>次に、アプリケーションのバージョンアップをします。Deploymentの内容を変更します。ここでは、コンテナーのイメージを変更します。これによりDeploymentが新しいReplicaSetを作成し、アプリケーションのバージョンアップを行います。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>～変更前～
      - image: xxx/frontend:v2.0.0
～変更後～
      - image: xxx/frontend:v1.0.0
</code></pre></div><p>次のコマンドを実行してDeploymentを <strong>更新</strong> します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f deployment.yaml 
deployment.apps/front configured
</code></pre></div><p>デプロイの状況は次のコマンドで確認できます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get deploy
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
front   3/3     <span style=color:#ae81ff>2</span>            <span style=color:#ae81ff>3</span>           2m55s

kubectl get rs
NAME               DESIRED   CURRENT   READY   AGE
front-7876d7bd66   <span style=color:#ae81ff>0</span>         <span style=color:#ae81ff>0</span>         <span style=color:#ae81ff>0</span>       3m21s
front-7b95f674dc   <span style=color:#ae81ff>3</span>         <span style=color:#ae81ff>3</span>         <span style=color:#ae81ff>3</span>       42s
</code></pre></div><p>内部でどのように入れ替わっているのか<code>Events</code>フィールドでログを見ていきましょう。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl describe deploy front

Events:
  Type    Reason             Age    From                   Message
  ----    ------             ----   ----                   -------
  Normal  ScalingReplicaSet  3m43s  deployment-controller  Scaled up replica set front-7876d7bd66 to <span style=color:#ae81ff>3</span>
  Normal  ScalingReplicaSet  64s    deployment-controller  Scaled up replica set front-7b95f674dc to <span style=color:#ae81ff>1</span>
  Normal  ScalingReplicaSet  54s    deployment-controller  Scaled down replica set front-7876d7bd66 to <span style=color:#ae81ff>2</span>
  Normal  ScalingReplicaSet  54s    deployment-controller  Scaled up replica set front-7b95f674dc to <span style=color:#ae81ff>2</span>
  Normal  ScalingReplicaSet  43s    deployment-controller  Scaled down replica set front-7876d7bd66 to <span style=color:#ae81ff>1</span>
  Normal  ScalingReplicaSet  43s    deployment-controller  Scaled up replica set front-7b95f674dc to <span style=color:#ae81ff>3</span>
  Normal  ScalingReplicaSet  33s    deployment-controller  Scaled down replica set front-7876d7bd66 to <span style=color:#ae81ff>0</span>
</code></pre></div><p>古いReplicaSet<code>front-7876d7bd66</code>から、新しいReplicaSet<code>front-7b95f674dc</code>に入れ替わっているのが分かります。</p><p>詳細にログをみると、以下が行われているのが分かります。</p><ol><li>新しいReplicaSetを作成</li><li>新しいReplicaSetのPodを増やす</li><li>古いReplicaSetのPodを減らす</li><li>古いReplicaSetのPodが0になるまで手順2と3を繰り返す</li></ol><p><img src=../docs/images/kubernetes-update-describe.png alt=kubernetes-update-describe></p><p>このようにサービスが停止しないように、内部で整合性をとりながら徐々にロールアウトしているのが分かります。</p><h4 id=ロールバック>ロールバック</h4><p>コンテナーイメージを変更し、アプリケーションのバージョンをv1からv2にバージョンアップできました。これをふたたびv1に戻したらどのような動きをするのでしょうか。マニフェストを修正し、kubectl applyコマンドを実行します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>～変更前～
      - <span style=color:#66d9ef>image</span>: xxx/frontend:v2<span style=color:#ae81ff>.0</span><span style=color:#ae81ff>.0</span>
～変更後～
      - <span style=color:#66d9ef>image</span>: xxx/frontend:v1<span style=color:#ae81ff>.0</span><span style=color:#ae81ff>.0</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>apply -f deployment.yaml 
deployment.apps/front configured
</code></pre></div><p>再度<code>kubectl describe</code>コマンドで詳細を確認すると<code>Annotations</code>フィールドが<code>revision=3</code>に上がっているのがわかります。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl describe deploy front

Name:                   front
Namespace:              default
CreationTimestamp:      Sun, <span style=color:#ae81ff>10</span> Oct <span style=color:#ae81ff>2021</span> 09:02:34 +0900
Labels:                 app<span style=color:#f92672>=</span>front
Annotations:            deployment.kubernetes.io/revision: <span style=color:#ae81ff>3</span>                      
</code></pre></div><p>なお、Deploymentのロールアウトは「Podを変更する」ためのしくみです。Podの<code>spec</code>-<code>template</code>以外の更新は、リビジョンが上がりません。たとえば<code>replicas</code>フィールドの値を変更してもPodの数が増えるだけで<code>revision</code>の値は同じままです。</p><p>また、Deploymentでは履歴を管理しますので、長期間運用していると履歴情報が大きくなります。そのためロールバックの世代を指定しておくことも検討しましょう。履歴はデフォルトで10世代を管理しますが、これを変更するときはDeploymentのマニフェストで<code>revisionHistoryLimit</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>を設定しましょう。</p><h4 id=ローリングアップデートの制御>ローリングアップデートの制御</h4><p>アプリケーションによってはアップデート中の性能縮退を最小に抑えたい場合もあります。Deploymentではこのローリングの処理を細かく制御できます。</p><h5 id=使用できないpodの制御maxunavailable>使用できないPodの制御（maxUnavailable）</h5><p>アップデート中に使用できなくなってもよいPodの最大数を指定するときはDeploymentマニフェストの<code>spec</code>-<code>strategy</code>-<code>rollingUpdate</code>-<code>maxUnavailable</code>を設定します。設定できる値はPodの数または、Podの割合(%)です。例えば10個のPodを起動したシステムで、<code>maxUnavailable</code>を30％に設定すると、アップデート中でも、常に利用可能なPodの総数が希望のPodの70％以上、つまり7個以上のPodがクラスター内で常に利用できる状態になります。</p><p><img src=../docs/images/kubernetes-update-maxunavailable.png alt=kubernetes-update-maxunavailable></p><h5 id=クラスターでpodを作成できる最大数maxsurge>クラスターでPodを作成できる最大数（maxSurge）</h5><p>ロールアウトをするときにどのぐらいの追加リソースを作成できるかを制御したいときは、Deploymentマニフェストの<code>spec</code>-<code>strategy</code>-<code>rollingUpdate</code>-<code>maxSurge</code>を設定します。たとえば、この値を30％に設定すると、ローリングアップデートが開始されるとすぐに新しいレプリカセットを拡大して、古いポッドと新しいポッドの合計数が130％を超えないように調整します。この値を100％にすると、クラスターの中にReplicasで指定した数だけ、新しいPodがすべて立ち上がってから、古いPodをスケールダウンさせます。これは、新旧のPodが共存することになりますので、ブルー/グリーンデプロイメントになります。安全性は高まりますが、一方2倍のPodを稼働させるため、Worker Nodeのコンピューティングリソースを多く用意しておく必要があります。</p><p><img src=../docs/images/kubernetes-update-maxsurge.png alt=kubernetes-update-maxsurge></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>apiVersion</span>: apps/v1
<span style=color:#66d9ef>kind</span>: Deployment
  <span style=color:#66d9ef>strategy</span>:
    <span style=color:#66d9ef>type</span>: RollingUpdate
    <span style=color:#66d9ef>rollingUpdate</span>: 
      <span style=color:#66d9ef>maxSurge</span>: <span style=color:#ae81ff>30</span>%
      <span style=color:#66d9ef>maxUnavailable</span>: <span style=color:#ae81ff>10</span>%
</code></pre></div><p>なお、<code>maxUnavailable</code>と<code>maxSurge</code>はいずれもレプリカ数を指定できますが、特別な理由がない限り全体のレプリカ数に対する割合で指定するのが良いでしょう。なぜならPodのレプリカ数はAutoScaleなどの設定で負荷に応じて動的に変化したとき、固定値にしておくと運用時に意図せぬ動作になってしまう可能性があるためです。</p><h3 id=kubernetes-に設定変更を宣言的に反映するには>Kubernetes に設定変更を宣言的に反映するには</h3><p>余談にはなりますが、Kubernetesにクラスタの設定情報を反映させる<code>kubernetes apply</code>コマンドは、該当のKubernetesリソースが存在しなければ新規作成し、存在すれば差分を反映するコマンドです。</p><p>Kubernetesを使う上でとても大事な概念である、<a href=https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/#declarative-object-configuration>宣言的な管理 &ndash; Declarative object configuration</a>ができます。</p><p>しかしながら、次のコマンドを実行してアプリケーションをリリースするとどうなるでしょうか？</p><pre><code>kubectl delete -f deployment.yaml
kubectl apply -f deployment.yaml
</code></pre><p>これは、<strong>「すでにあるDeploymentリソースをいったん削除」</strong> したあとで <strong>「Deploymentリソースを新規に作成している」</strong> ということになります。</p><p>この方式だとダウンタイムが発生します。そして、本ブログで説明したKubernetesが持つローリングアップデートの機能なども有効に働きません。</p><p>また、Podの終了処理(iptablesの書き換え/kubelet=>container runtimeによるContainerの削除)のタイミングの関係で通信エラーになる可能性も考えられます。</p><p>詳細については、<a href=https://asashiho.github.io/spring-graceful/spring-graceful/>Spring WebFlux + KuberntesでアプリのGraceful Shutdownを実装する</a>で、Podの終了処理の詳細についてまとめましたので、あわせて読んでいただけるといいかもしれません。</p><p>なお、本番環境ではこのエントリのように<code>kubectl</code>コマンドを実行してアプリを更新するのではなく、CI/CD環境を整備し、デプロイの処理を自動化することで事故を防ぐよう検討する必要があります。最近のトレンドとしては、GitOpsなどを導入しているケースが多くなっています。</p><p>たとえば私が今お仕事でセールスを担当している<a href=https://docs.microsoft.com/en-us/azure/azure-arc/kubernetes/overview>Azure Arc Enabled Kubernetes</a>では、GitOpsのしくみとして CNCFのIncubating projectであるオープンソースの<a href=https://fluxcd.io/>Flux</a>を内部で使っていたりします。</p><h2 id=まとめ>まとめ</h2><p>KubernetesのDeploymentは、Kubernetesリソースの中でも最も重要かつ奥深いリソースなので、今一度基本に立ち返り、使い方だけでなくKubernetesのしくみや世界観も含めて理解しておくとよいなとおもいます。</p><ul><li><a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/>参考: Deployments</a></li><li><a href=https://www.shoeisha.co.jp/book/detail/9784798157849>参考: しくみがわかるKubernetes</a></li></ul><p>以上</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#revision-history-limit>revisionHistoryLimit</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></main></body></html>