<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=ja-jp lang=ja-jp><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.64.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Spring WebFlux + WebClientでリトライ処理を実装する &#183; ASA Blog</title><meta name=description content="Spring WebFlux + WebClientでリトライ処理を実装する説明です。"><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link type=text/css rel=stylesheet href=https://use.fontawesome.com/releases/v5.0.6/css/all.css><link type=text/css rel=stylesheet href=https://aakira.app/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css integrity=sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0 crossorigin=anonymous><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css integrity=sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js integrity=sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js integrity=sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF crossorigin=anonymous onload=renderMathInElement(document.body);></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},{left:"\\(",right:"\\)",display:false}]});});</script><meta property="og:site_name" content="ASA Blog"><meta property="og:title" content="Spring WebFlux + WebClientでリトライ処理を実装する"><meta property="og:url" content="https://asashiho.github.io/spring-webflux-retry/spring-webflux-retry/"><meta property="og:type" content="article"><meta name=twitter:card content="summary"><meta name=twitter:site content="@_dr_asa"><meta name=twitter:creator content="@_dr_asa"><meta property="twitter:title" content="Spring WebFlux + WebClientでリトライ処理を実装する"><meta property="og:description" content="Spring WebFlux + WebClientでリトライ処理を実装する説明です。"><meta property="twitter:description" content="Spring WebFlux + WebClientでリトライ処理を実装する説明です。"><meta property="og:image" content="https://asashiho.github.io/thumbnails/prof.jpg"><meta property="og:image:url" content="https://asashiho.github.io/thumbnails/prof.jpg"></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://asashiho.github.io/><h1>ASA Blog</h1></a><p class=lead>enjoy a laid-back life</p></div><nav><ul class=sidebar-nav><li><a href=https://asashiho.github.io/>Home</a></li><li><a href=https://github.com/asashiho/>GitHub</a></li><li><a href=https://www.linkedin.com/in/shiho-asa/>LinkedIn</a></li></ul></nav><p>&copy; 2021. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Spring WebFlux + WebClientでリトライ処理を実装する</h1><time datetime=2021-09-24T00:00:00Z class=post-date>Fri, Sep 24, 2021</time>
<a href="http://twitter.com/intent/tweet?url=https%3a%2f%2fasashiho.github.io%2fspring-webflux-retry%2fspring-webflux-retry%2f&text=Spring%20WebFlux%20%2b%20WebClient%e3%81%a7%e3%83%aa%e3%83%88%e3%83%a9%e3%82%a4%e5%87%a6%e7%90%86%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%99%e3%82%8b" target=_blank title=Tweet><i class="fab fa-twitter"></i></a>&ensp;
<a href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fasashiho.github.io%2fspring-webflux-retry%2fspring-webflux-retry%2f&t=Spring%20WebFlux%20%2b%20WebClient%e3%81%a7%e3%83%aa%e3%83%88%e3%83%a9%e3%82%a4%e5%87%a6%e7%90%86%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%99%e3%82%8b" target=_blank title=Facebook><i class="fab fa-facebook"></i></a>&ensp;
<a href="https://plus.google.com/share?url=https%3a%2f%2fasashiho.github.io%2fspring-webflux-retry%2fspring-webflux-retry%2f" target=_blank title=google+><i class="fab fa-google-plus"></i></a><hr><p>最近業務でお手伝いさせていただく案件のなかでも、Java on Kubernetesなパターンが増えてきています。Kubernetesに限らずクラウドのマネージドPaaSで動かすにはアプリケーション側でもクラウドネイティブを考慮した実装が必要になり、特に耐障害性や回復性などを意識した実装が大事になってきます。</p><p>しっかりアプリケーション方式設計されたシステムでは、大きな問題もなく開発者からみると「クラウド超便利」「マネージド最高か！」となりますが、ごくまれに「オンプレで雰囲気で動いていたそのままのアプリをクラウドに持ってきた」or「オンプレを前提とした開発手法で実装されたレガシーアプリをクラウドネイティブなPaaSサービスで動かしてみた」というケースで問題が発生することがあります。</p><hr><p>アプリケーション開発者の観点でどういうところに注意すればよいかは、いずれきちんとまとめますか</p><ul><li>通信先のサービス(DB/外部API)は常に動いていると思うべからず</li><li>死に際を美しく(Graceful Shutdown)</li><li>秘匿情報・環境依存値の取り扱い</li><li>ステートレスにすべし</li></ul><p>あたりが大事なポイントになってくるかなと思っています。</p><p>このエントリでは、１つ目の</p><p><strong>通信先のサービス(DB/外部API)は常に動いていると思うべからず</strong></p><p>対策の一つであるアプリケーションのリトライ処理の実装について、Spring WebFluxのWebClientを使った実装の例を説明します。</p><h1 id=そもそもリトライ処理とは>そもそも、リトライ処理とは？</h1><p>プリセールスなので、クラウドとは？わかりやすく説明して！といわれると「お客様のDXを実現するもので、ビジネス変化の速度をアクセラレートする(2階微分)ために不可欠なものです」みたいなことを言ってしまいがちですが、、、</p><p>アプリケーション開発者の観点からクラウドを一言で説明せよ、となると</p><p>「<strong>クラウド事業者が運用している巨大インフラ(サーバ/ネットワーク/ストレージ)を利用できるサービス。利用するにはAPIをCallするだけ、利用料金は従量課金、SLAが規定値を下回ったら返金</strong> 」</p><p>というごくシンプルなものです。</p><p>たとえば99.99%のクラウドサービスを利用した場合、1か月のうち、4.3分は停止する可能性があります。それが月次の定期メンテナンスのタイミング/深夜のユーザ利用率の低い時間帯/優先度の低いシステムであれば大きな問題にはならないかもしれません。しかし相手は機械。空気を読むことはしません。金融システムにおける五十日の決済処理のような場合も十分にありえます。あとは分かるな？</p><table><thead><tr><th>SLA</th><th>停止時間(月)</th></tr></thead><tbody><tr><td>99.9%</td><td>43分</td></tr><tr><td>99.95%</td><td>21分</td></tr><tr><td>99.99%</td><td>4.3分</td></tr><tr><td>99.999%</td><td>25.8秒</td></tr></tbody></table><p>そもそも、クラウドでなくとも多数のコンポーネントから構成される大規模分散システムでは系内の障害をゼロにすることは不可能なため、障害をゼロにしよう！というアプローチではなく、回復性を高めよう！という観点でのアプリケーション処理方式の一つとしてリトライ処理を実装されてきたとおもいます。特にミッションクリティカル系システムでは、いにしえより必ず検討されてきた方式なので、令和の今あらためての新鮮味はないでしょう。</p><p>とはいえ、リトライ処理とは文字通り「リクエストを再試行する」ものなのですが、いつ、だれが、どこで、どうやってリトライを行えばいいのかはむずかしい問題です。</p><h2 id=exponential-backoff-and-jitte--指数関数的バックオフとジッター>Exponential backoff and jitte ―― 指数関数的バックオフとジッター</h2><p>リクエストもまばらでの規模が小さい場合は、n秒ごとに再試行する、などの固定値で実装するケースもあるかとおもいますが、大規模ミッションクリティカルシステムの場合データセンター障害のような大規模なトラブル時を考慮する必要があります。大規模障害時は多くのサーバ/サービスが停止していると想定されます。そのため、多数のクライアントからのリクエストがエラーになり、結果的に多数のリトライが送信されることになります。</p><p>このとき、クライアント側で固定値でリトライ処理を実装すると、全クライアントがn秒ごとに同じタイミングでリトライ処理を実施することになります。API側からみると、n秒ごとに多数のリクエストに受けることになり、過剰な負荷がかかることになります。さらにリトライストームでカスケード障害を引き起こす可能性もあります。</p><p>そのため、リトライする間隔が大事になってきます。どのような間隔でリトライを行えば、系全体でみたときに効率的なのかを解決する手法として、「<strong>Exponential backoff and jitter</strong>」という有名なリトライのアルゴリズムがあります。</p><p>Exponential backoffは、処理が失敗した後のリトライする間隔を許容可能な範囲で徐々に減らしつつ継続するアルゴリズムです。具体的には、再試行する度に、1秒後、2秒後、4秒後と指数関数的に待ち時間を長くしていきます。これにより、全体のリトライ回数を抑え、リクエストが殺到するのを防ぎます。</p><p>一般的に分散システムでは複数のコンポーネントが協調して動作します。そのためリトライのタイミングをわざとずらして衝突を回避させるために、<code>random</code>関数を用いたjitterというゆらぎをいれます。</p><blockquote><p>ちなみにAzureでは一時障害がなぜ発生するのか？どう対処すればよいか、アンチパターンは？などのガイダンスがまとまっておりますので、ぜひ。2016年のドキュメントですが、色褪せない内容になっています。
<a href=https://docs.microsoft.com/en-us/azure/architecture/best-practices/transient-faults>Transient fault handling</a></p></blockquote><h1 id=低slaなrest-apiの実装>低SLAなREST APIの実装</h1><p>それでは、具体的に実装を説明していきたいのですが、たとえばAzure Cognitive ServicesのAPIのSLAは99.9%ですので、1日当たり1.4分しかエラーが返ってきません。これではリトライ処理のテストができないので、もっともっとSLAの低いAPIが必要になります。</p><p>そこでリトライ処理を実装するときにテストで必要となる「<strong>SLAの低いRESR APIサービス</strong>」を用意します。Spring/JPA/H2DBを使って単純にJSONの値を返すたけのAPIですので、コードの説明は行いません。</p><p>Docker Imageを作成したので、次のコマンドを実行してコンテナを起動します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker run -it --rm -p 8081:8081 asashiho/retry-backend:v0.0.1
</code></pre></div><p>次のEndpointにアクセスしても、リクエストの30%しか200を返しません。残りの70%は500を返します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>GET http://localhost:8081/employees
</code></pre></div><p>運が良い場合、以下のJSONが返ります。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>[
  {
    <span style=color:#f92672>&#34;id&#34;</span>: <span style=color:#ae81ff>1</span>,
    <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;舞黒 太郎&#34;</span>,
    <span style=color:#f92672>&#34;role&#34;</span>: <span style=color:#e6db74>&#34;Support Engineer&#34;</span>
  },
  {
    <span style=color:#f92672>&#34;id&#34;</span>: <span style=color:#ae81ff>2</span>,
    <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;阿重瑠 花子&#34;</span>,
    <span style=color:#f92672>&#34;role&#34;</span>: <span style=color:#e6db74>&#34;Cloud Solution Architect&#34;</span>
  }
]
</code></pre></div><p>いい感じです。これでSLA 30%のAPIができました。</p><h1 id=spring-webfluxwebclientでリトライ処理を実装する>Spring WebFlux/WebClientでリトライ処理を実装する</h1><h2 id=spring-webfluxとは>Spring WebFluxとは</h2><p>JavaでWebアプリケーションを開発するためのフレームワークとして、Spring Frameworkの「Spring MVC」が有名で、これまで広く使われていました。Spring MVCはサーブレットをベースとしており、Tomcatなどのサーブレットコンテナの上で動作するのが特徴です。ただ、Spring MVCのリクエスト処理方式は同時処理数分だけスレッドを必要とするため、クラウドのように利用したコンピューティングリソースに課金されるケースでは、必ずしも効率がよいとはいえません。</p><p>「Spring WebFlux」は、NettyなどのノンブロッキングI/Oベースのアプリケーションサーバ上で動作します。そして、ネットワークアクセスやDBアクセスなどのI/O処理の呼び出しに対して、1つのスレッドで複数のリクエストを処理でき少ないスレッドで実行できるため、メモリサイズやCPUの使用を減らすことが可能です。特にKubernetesのように、コンピューティングリソースの配置を細かくチューニングできるプラットフォームを使っている場合、ちりもつもれば山となる節約効果も期待できます。</p><p>Spring WebFluxでは「Reactor」によるリアクティブプログラミングを採用しています。リアクティブプログラミングとは、データに着目したイベント駆動型のプログラミングの一種で、通知されるデータを受け取って処理を行うハンドラを実装することによって連続的なデータを処理する手法です。Reactorはリアクティブプログラミングを実現するためのライブラリの一つであり、ノンブロッキングで非同期なリアクティブプログラミングの仕組みを提供しています。
Spring MVCでは抽象化レイヤーにServlet APIを使っていましたが、Spring WebFluxではReactive Streams Adaptersをを使うことによって低レベルなノンブロッキングI/Oの仕組みを隠蔽し、より抽象度の高いかたちでノンブロッキングな処理を実装できるようにしています。</p><h2 id=spring-webfluxによるwebアプリケーションの作成>Spring WebFluxによるWebアプリケーションの作成</h2><p>Spring WebFluxを使ったWebアプリケーションは「Spring Initializr」を使ってプロジェクトのひな型を作成できます。その際、[ADD DEPENDENCIES]で[Spring Reactive Web]を追加します。</p><p>ダウンロードしたZIPのpom.xmlを確認すると以下のdependencyが登録されています。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;dependency</span><span style=color:#f92672>&gt;</span>
	<span style=color:#f92672>&lt;groupId</span><span style=color:#f92672>&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
	<span style=color:#f92672>&lt;artifactId</span><span style=color:#f92672>&gt;</span>spring-boot-starter-webflux<span style=color:#f92672>&lt;/artifactId&gt;</span>
<span style=color:#f92672>&lt;/dependency&gt;</span>
</code></pre></div><p>簡単です。</p><h2 id=webclientによるrest-apiの呼び出し>WebClientによるREST APIの呼び出し</h2><p>Spring WebFluxでは、WebClientを使用して外部のREST APIを呼び出しできます。WebClientはノンブロッキングなHTTPリクエストを実現するための機能で、メソッドチェインによってHTTPリクエストを処理できます。Spring MVCではRestTemplateというHTTPクライアントを提供していますが、RestTemplateはSpring Framework 5.0でメンテナンスモードとなり、今後はWebClientを使用することが推奨されています。</p><p>GETリクエストはWebClientのgetメソッドを使います。Endpointは<code>uri</code>メソッドに指定します。
ここでは指定していませんが、<code>accept</code>メソッドを使用するとAcceptヘッダなどのリクエストに必要な情報を設定できます。<code>retrive</code>メソッドを実行したあと、レスポンスの処理方法を設定します。</p><p>ここでは、低SLAなAPIから取得したJSONを<code>Employee[]</code>に格納しています。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> WebClient webClient <span style=color:#f92672>=</span> WebClient<span style=color:#f92672>.</span><span style=color:#a6e22e>builder</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>

<span style=color:#66d9ef>public</span> Mono<span style=color:#f92672>&lt;</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>return</span> webClient<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>uri</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getUri</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retrieve</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>bodyToMono</span><span style=color:#f92672>(</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
</code></pre></div><p>WebClientの処理結果は<code>Flux&lt;></code>または<code>Mono&lt;></code>でラッピングされています。</p><p><code>Flux&lt;></code>はReactive Streamsにおける<code>Publisher</code>インタフェースを実装しており、0個以上のデータを持つデータ列を扱うためのクラスです。
一方の<code>Mono&lt;></code>は<code>Publisher</code>インタフェースを実装したクラスですが、0個または1個のデータを扱うところが違いです。</p><p><code>Flux&lt;></code>と<code>Mono&lt;></code>には<code>operator</code>が用意されており、<code>operator</code>をメソッドチェーンで繋げていくことによって処理を実装できます。<code>operator</code>はラムダ関数を引数として受け取り、ラムダ関数で定義した内容に基づいた処理を行うPublisherを生成します。</p><p>少し脱線しますが、たとえは<code>map</code>は個々のデータに対して処理を実行する<code>operator</code>で値を100倍したいときは次のようなコードを書きます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Flux<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> 2<span style=color:#f92672>,</span> 3<span style=color:#f92672>,</span> 4<span style=color:#f92672>,</span> 5<span style=color:#f92672>)</span>
  <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> i <span style=color:#f92672>*</span> 100<span style=color:#f92672>)</span>
  <span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>d <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span>d<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>

Mono<span style=color:#f92672>.</span><span style=color:#a6e22e>just</span><span style=color:#f92672>(</span>10<span style=color:#f92672>)</span>
  <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> i <span style=color:#f92672>*</span> 100<span style=color:#f92672>)</span>
  <span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>d <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span>d<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>
</code></pre></div><p>そのほかにも、非同期にデータを処理する<code>flatMap</code>や、条件に合致するデータのみを抽出する<code>filter</code>などがあります。便利。</p><p><img src=https://projectreactor.io/docs/core/release/api/reactor/core/publisher/doc-files/marbles/flux.svg alt></p><p><a href=https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html>https://projectreactor.io/</a></p><h2 id=webclientによるrest-api呼び出しのリトライ処理>WebClientによるREST API呼び出しのリトライ処理</h2><p>リトライ処理の実装も実にシンプルで<code>Mono&lt;></code>と<code>Flux&lt;></code>には2つの<code>Retry operator</code>が用意されています。</p><h3 id=retry-operatorの場合>retry operatorの場合</h3><p><code>retry</code>メソッドに再試行したい回数を指定します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> Mono<span style=color:#f92672>&lt;</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>return</span> webClient<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>uri</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getUri</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retrieve</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>bodyToMono</span><span style=color:#f92672>(</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retry</span><span style=color:#f92672>(</span>3<span style=color:#f92672>)</span><span style=color:#f92672>;</span>
</code></pre></div><p>このケースだとWebClientからどのようなエラーが返されても最大3回リトライされます。また<code>Long.MAX_VALUE</code>を渡すと無限に再試行するのでご注意ください。</p><p><img src=https://projectreactor.io/docs/core/release/api/reactor/core/publisher/doc-files/marbles/retryForFlux.svg alt="retry operator"></p><h3 id=retrywhen-operatorの場合>retryWhen operatorの場合</h3><p>実際にプロダクションで使うときは、もうちょっと細かいチューニングが必要です。その場合はretryWhen operatorを使います。</p><p><img src=https://projectreactor.io/docs/core/release/api/reactor/core/publisher/doc-files/marbles/retryWhenSpecForFlux.svg alt="retryWhen operator"></p><p>たとえば、最大3回リトライするけど、それぞれの間に2秒の一定間隔をあけたい場合です。通信先が一時障害のとき、そんなにすぐには復旧しないケースもあるでしょう。ちょっと待て、そう焦るでない、、、というケースです。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> Mono<span style=color:#f92672>&lt;</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>return</span> webClient<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>uri</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getUri</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retrieve</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>bodyToMono</span><span style=color:#f92672>(</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retryWhen</span><span style=color:#f92672>(</span>Retry<span style=color:#f92672>.</span><span style=color:#a6e22e>fixedDelay</span><span style=color:#f92672>(</span>3<span style=color:#f92672>,</span>Duration<span style=color:#f92672>.</span><span style=color:#a6e22e>ofSeconds</span><span style=color:#f92672>(</span>2<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>リトライの間隔を一定ではなく、徐々に長くしたいこともあります。ただでさえ値を返せなくてイラっとしているところ、何度もしつこく催促されるとAPIもやる気がなくなるでしょう。</p><p>次の場合は、最大3回リトライするけど、リトライ間隔を指数関数的にのばしたい場合です。おおよそ2秒後・4秒後・8秒後にリトライされます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> Mono<span style=color:#f92672>&lt;</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>return</span> webClient<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>uri</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getUri</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retrieve</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>bodyToMono</span><span style=color:#f92672>(</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retryWhen</span><span style=color:#f92672>(</span>Retry<span style=color:#f92672>.</span><span style=color:#a6e22e>backoff</span><span style=color:#f92672>(</span>3<span style=color:#f92672>,</span>Duration<span style=color:#f92672>.</span><span style=color:#a6e22e>ofSeconds</span><span style=color:#f92672>(</span>2<span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=jitterによる衝突回避>jitterによる衝突回避</h3><p><code>backoff opetator</code>にはjitterの値をチューニングできます。デフォルトでは、0.5に設定されています。これは、遅延の最大50％のjitterを入れます。設定可能な値は0-1までで、0はjitterなし、1はdelayに対して100%のjitterを指定することになります。</p><p>次の例は、0.75のjitterを入れた場合です。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> Mono<span style=color:#f92672>&lt;</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>return</span> webClient<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>uri</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getUri</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retrieve</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>bodyToMono</span><span style=color:#f92672>(</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retryWhen</span><span style=color:#f92672>(</span>Retry<span style=color:#f92672>.</span><span style=color:#a6e22e>backoff</span><span style=color:#f92672>(</span>3<span style=color:#f92672>,</span> Duration<span style=color:#f92672>.</span><span style=color:#a6e22e>ofSeconds</span><span style=color:#f92672>(</span>2<span style=color:#f92672>)</span><span style=color:#f92672>)</span>
            <span style=color:#f92672>.</span><span style=color:#a6e22e>jitter</span><span style=color:#f92672>(</span>0<span style=color:#f92672>.</span><span style=color:#a6e22e>75</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=ログの出力>ログの出力</h3><p>リトライ処理をするときに、ログ出力したくなることもあるとおもいます。その場合は、<code>doBeforeRetry</code>/<code>doAfterRetry</code>メソッドでリトライ処理のトリガー時にロギングを入れてあげれはいいかなと思います。受け取った<a href=https://projectreactor.io/docs/core/release/api/reactor/util/retry/Retry.RetrySignal.html>RetrySignal</a>の<code>totalRetries</code>でリトライの回数-1が取得できます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> Mono<span style=color:#f92672>&lt;</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>return</span> webClient<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>uri</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getUri</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retrieve</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>bodyToMono</span><span style=color:#f92672>(</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
        <span style=color:#f92672>.</span><span style=color:#a6e22e>retryWhen</span><span style=color:#f92672>(</span>Retry<span style=color:#f92672>.</span><span style=color:#a6e22e>backoff</span><span style=color:#f92672>(</span>3<span style=color:#f92672>,</span> Duration<span style=color:#f92672>.</span><span style=color:#a6e22e>ofSeconds</span><span style=color:#f92672>(</span>2<span style=color:#f92672>)</span><span style=color:#f92672>)</span>
            <span style=color:#f92672>.</span><span style=color:#a6e22e>jitter</span><span style=color:#f92672>(</span>0<span style=color:#f92672>.</span><span style=color:#a6e22e>75</span><span style=color:#f92672>)</span>
            <span style=color:#f92672>.</span><span style=color:#a6e22e>doBeforeRetry</span><span style=color:#f92672>(</span>sig <span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
                log<span style=color:#f92672>.</span><span style=color:#a6e22e>error</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Retrying: &#34;</span> <span style=color:#f92672>+</span> sig<span style=color:#f92672>.</span><span style=color:#a6e22e>totalRetries</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p><code>@RestController</code>アノテーションのついた適当なControllerクラスを書き、<code>@GetMapping</code>アノテーションでパスを設定し、サービスを呼び出します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@GetMapping</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/retry&#34;</span><span style=color:#f92672>)</span>
<span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>retry</span><span style=color:#f92672>(</span>Model model<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Start: &#34;</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>
    Mono<span style=color:#f92672>&lt;</span>Employee<span style=color:#f92672>[</span><span style=color:#f92672>]</span><span style=color:#f92672>&gt;</span> userData <span style=color:#f92672>=</span> frontService<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span>

    model<span style=color:#f92672>.</span><span style=color:#a6e22e>addAttribute</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;userData&#34;</span><span style=color:#f92672>,</span> userData<span style=color:#f92672>)</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;retry&#34;</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>/retryにアクセスすると、以下のようにロギングされます。3回がんばってリトライしたけど結局だめで、<code>RetryExhaustedException</code>が捕捉されています。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>2021-09-24 15:18:50.277  INFO <span style=color:#ae81ff>1806</span> --- <span style=color:#f92672>[</span>or-http-epoll-1<span style=color:#f92672>]</span> c.e.front.controller.FrontController     : Start: 
2021-09-24 15:18:50.293 ERROR <span style=color:#ae81ff>1806</span> --- <span style=color:#f92672>[</span>or-http-epoll-6<span style=color:#f92672>]</span> com.example.front.service.FrontService   : Retrying: <span style=color:#ae81ff>0</span>
2021-09-24 15:18:53.220 ERROR <span style=color:#ae81ff>1806</span> --- <span style=color:#f92672>[</span>or-http-epoll-3<span style=color:#f92672>]</span> com.example.front.service.FrontService   : Retrying: <span style=color:#ae81ff>1</span>
2021-09-24 15:18:56.417 ERROR <span style=color:#ae81ff>1806</span> --- <span style=color:#f92672>[</span>or-http-epoll-4<span style=color:#f92672>]</span> com.example.front.service.FrontService   : Retrying: <span style=color:#ae81ff>2</span>
2021-09-24 15:19:08.181 ERROR <span style=color:#ae81ff>1806</span> --- <span style=color:#f92672>[</span>or-http-epoll-5<span style=color:#f92672>]</span> a.w.r.e.AbstractErrorWebExceptionHandler : <span style=color:#f92672>[</span>24868deb-2<span style=color:#f92672>]</span>  <span style=color:#ae81ff>500</span> Server Error <span style=color:#66d9ef>for</span> HTTP GET <span style=color:#e6db74>&#34;/retry&#34;</span>

reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
</code></pre></div><p>ログの時間も見てみましょう。リトライ間隔が徐々に増えているのが分かります。</p><table><thead><tr><th>回数</th><th>時刻</th><th>間隔</th></tr></thead><tbody><tr><td>0</td><td>15:18:50.277</td><td>&ndash;</td></tr><tr><td>1</td><td>15:18:50.293</td><td>00:02.9</td></tr><tr><td>2</td><td>15:18:53.220</td><td>00:03.2</td></tr><tr><td>3</td><td>15:18:56.417</td><td>00:11.9</td></tr></tbody></table><hr><p>なお、プロダクションで利用する場合は、リトライのパラメータ値などはアプリケーション外部から注入できるようにしておくとよいと思います。<code>application.properties</code>に設定して<code>@ConfigurationProperties</code>アノテーションを設定することで、DIコンテナに自動的にインジェクションされます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#960050;background-color:#1e0010>#</span> retry parameter
retry<span style=color:#f92672>.</span><span style=color:#a6e22e>backoff</span><span style=color:#f92672>=</span>10
retry<span style=color:#f92672>.</span><span style=color:#a6e22e>duration</span><span style=color:#f92672>=</span>2
retry<span style=color:#f92672>.</span><span style=color:#a6e22e>jitter</span><span style=color:#f92672>=</span>0<span style=color:#f92672>.</span><span style=color:#a6e22e>75</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>package</span> com.example.front.util<span style=color:#f92672>;</span>

<span style=color:#f92672>import</span> org.springframework.boot.context.properties.ConfigurationProperties<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> lombok.Getter<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> lombok.Setter<span style=color:#f92672>;</span>

<span style=color:#f92672>import</span> org.springframework.stereotype.Component<span style=color:#f92672>;</span>

<span style=color:#a6e22e>@Component</span>
<span style=color:#a6e22e>@ConfigurationProperties</span><span style=color:#f92672>(</span>prefix<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;retry&#34;</span><span style=color:#f92672>)</span>
<span style=color:#a6e22e>@Getter</span> <span style=color:#a6e22e>@Setter</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RetryProperties</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> backoff<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> duration<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span> jitter<span style=color:#f92672>;</span>

<span style=color:#f92672>}</span>
</code></pre></div><p><code>Configuration Properties</code>を使うと型安全なプロパティ設定が簡単にできて良いです。</p><h2 id=おまけ>※おまけ</h2><p>クラウドの耐障害性検証やカオス注入などのトラブル検証などで、今回の低SLAなREST APIを今後も使うシーンがあるかもしれない、と思い、<a href=https://docs.microsoft.com/ja-jp/azure/container-instances/>Azure Container Instance</a>を使って簡易的なREST APIを作成する手順を書きました。</p><p>まず、Azureの東日本リージョンにリソースグループを作成します</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>az login
RG_NAME<span style=color:#f92672>=</span>whimsical-api
ACI_NAME<span style=color:#f92672>=</span>whimsical-api

az group create -n $RG_NAME -l japaneast
</code></pre></div><p>次のコマンドを実行してAzure Container Instanceを起動します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>az container create <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -g $RG_NAME <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -n $ACI_NAME <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --image asashiho/retry-backend:v0.0.1 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --dns-name-label whimsical-api <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --ports <span style=color:#ae81ff>8081</span>
</code></pre></div><p>次のコマンドを実行すると、ACIの完全修飾ドメイン名(FQDN)とそのプロビジョニング状態が表示されます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>az container show <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -g $RG_NAME <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -n $ACI_NAME <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --query <span style=color:#e6db74>&#34;{FQDN:ipAddress.fqdn,ProvisioningState:provisioningState}&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --out table
</code></pre></div><p>Visual Studio Code Extentionの<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">REST Client</a>などでACIのEndpointにアクセスします。</p><ul><li>常に値を返すEndpoint</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>GET http://whimsical-api.japaneast.azurecontainer.io:8081/employees/1
</code></pre></div><ul><li>リクエストの30%にだけ200で応答するEndpoint</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>GET http://whimsical-api.japaneast.azurecontainer.io:8081/employees
</code></pre></div><p>ACIのリソースグループを削除する場合は次のコマンドを実行します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>az group delete -n $RG_NAME
</code></pre></div><p>ACIはDockerコンテナを策っと動かすときには便利です。</p><h2 id=まとめ>まとめ</h2><p>本エントリーでは、Spring WebFlux/WebClientを使った外部REST APIの呼び出しとリトライ処理の実装についてまとめました。</p><p>リトライ大事。回復性大事。</p><p>以上</p><ul><li><a href=https://spring.pleiades.io/guides/gs/reactive-rest-service/>参考: WebFlux REST API と WebClient</a></li><li><a href=https://projectreactor.io/docs/core/release/api/reactor/util/retry/Retry.html>参考: Class Retry</a></li><li><a href=https://projectreactor.io/docs/core/release/api/reactor/util/retry/RetryBackoffSpec.html#jitter-double->参考: Class RetryBackoffSpec</a></li><li><a href=https://www.baeldung.com/spring-webflux-retry>参考: Guide to Retry in Spring WebFlux</a></li></ul></div></main></body></html>