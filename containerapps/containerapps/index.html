<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=ja-jp lang=ja-jp><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.64.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Azure Container Apps/GitHub Actionsを使ったコンテナアプリのブルーグリーンデプロイメント &#183; ASA Blog</title><meta name=description content="Azure Container Apps/GitHub Actionsを使ったブルーグリーンデプロイメントに関するDennis Zielkeのブログの翻訳記事です。"><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://asashiho.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link type=text/css rel=stylesheet href=https://use.fontawesome.com/releases/v5.0.6/css/all.css><link type=text/css rel=stylesheet href=https://aakira.app/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css integrity=sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0 crossorigin=anonymous><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css integrity=sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js integrity=sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js integrity=sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF crossorigin=anonymous onload=renderMathInElement(document.body);></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},{left:"\\(",right:"\\)",display:false}]});});</script><meta property="og:site_name" content="ASA Blog"><meta property="og:title" content="Azure Container Apps/GitHub Actionsを使ったコンテナアプリのブルーグリーンデプロイメント"><meta property="og:url" content="https://asashiho.github.io/containerapps/containerapps/"><meta property="og:type" content="article"><meta name=twitter:card content="summary"><meta name=twitter:site content="@_dr_asa"><meta name=twitter:creator content="@_dr_asa"><meta property="twitter:title" content="Azure Container Apps/GitHub Actionsを使ったコンテナアプリのブルーグリーンデプロイメント"><meta property="og:description" content="Azure Container Apps/GitHub Actionsを使ったブルーグリーンデプロイメントに関するDennis Zielkeのブログの翻訳記事です。"><meta property="twitter:description" content="Azure Container Apps/GitHub Actionsを使ったブルーグリーンデプロイメントに関するDennis Zielkeのブログの翻訳記事です。"><meta property="og:image" content="https://asashiho.github.io/thumbnails/prof.jpg"><meta property="og:image:url" content="https://asashiho.github.io/thumbnails/prof.jpg"></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://asashiho.github.io/><h1>ASA Blog</h1></a><p class=lead>enjoy a laid-back life</p></div><nav><ul class=sidebar-nav><li><a href=https://asashiho.github.io/>Home</a></li><li><a href=https://github.com/asashiho/>GitHub</a></li><li><a href=https://www.linkedin.com/in/shiho-asa/>LinkedIn</a></li></ul></nav><p>&copy; 2022. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Azure Container Apps/GitHub Actionsを使ったコンテナアプリのブルーグリーンデプロイメント</h1><time datetime=2021-11-09T00:00:00Z class=post-date>Tue, Nov 9, 2021</time>
<a href="http://twitter.com/intent/tweet?url=https%3a%2f%2fasashiho.github.io%2fcontainerapps%2fcontainerapps%2f&text=Azure%20Container%20Apps%2fGitHub%20Actions%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%9f%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%82%a2%e3%83%97%e3%83%aa%e3%81%ae%e3%83%96%e3%83%ab%e3%83%bc%e3%82%b0%e3%83%aa%e3%83%bc%e3%83%b3%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%83%a1%e3%83%b3%e3%83%88" target=_blank title=Tweet><i class="fab fa-twitter"></i></a>&ensp;
<a href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fasashiho.github.io%2fcontainerapps%2fcontainerapps%2f&t=Azure%20Container%20Apps%2fGitHub%20Actions%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%9f%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%82%a2%e3%83%97%e3%83%aa%e3%81%ae%e3%83%96%e3%83%ab%e3%83%bc%e3%82%b0%e3%83%aa%e3%83%bc%e3%83%b3%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%83%a1%e3%83%b3%e3%83%88" target=_blank title=Facebook><i class="fab fa-facebook"></i></a>&ensp;
<a href="https://plus.google.com/share?url=https%3a%2f%2fasashiho.github.io%2fcontainerapps%2fcontainerapps%2f" target=_blank title=google+><i class="fab fa-google-plus"></i></a><hr><p><strong>このブログエントリは、MicrosoftのGlobal Blackbelt for cloud native applicationsであるDennis Zielkeのブログ<a href=https://denniszielke.medium.com/implementing-continuous-blue-green-deployments-on-azure-container-apps-by-using-github-actions-b4cd5183adb8>Implementing continuous blue/green deployments on Azure Container Apps by using GitHub Actions</a>について、Dennisの承諾を得て日本語に翻訳しています。</strong></p><hr><p>Microsoft Azureは、GitHub ActionsやAzure Monitorに加えて、新しいServerless Application Platformである「Container Apps」をリリースしました。そこで私は、KubernetesとAzure上でBlue/Greenの継続的デプロイを行うというシナリオを再検討し、新しい技術スタックを使ってそれを実装する方法を紹介します。もし、Container Appsを使う機会がないけれと自分で試してみたいと思っているのであれば、お勧めの記事です。</p><p>ここでは、以下の機能を試します:</p><ul><li>コンテナのランタイムとしてのAzure Container Apps</li><li>クラスタ内でのサービス間の呼び出しを行うDapr</li><li>トラフィックに応じてコンテナを自動的にスケーリングするKeda</li><li>リビジョン間のトラフィック分割を実装するためのEnvoy</li><li>Application Insightsでの分散トレーシング</li><li>Azure ADのFederated Service Identityに対応したGitHub Actions</li></ul><h2 id=システムの概要>システムの概要</h2><p>この記事の目的は、ブルー/グリーンデプロイメントを実施し、GitHub Actionsを使用した場合に、Azure Container Appsでのダウンタイムのない継続的デプロイメントがどれだけ簡単かを確認することです。もちろん、他のCI/CDツールチェーンを使用することもできますが、ロジックのほとんどがシェルスクリプトで実装されているため、プロセスを移行する方法を簡単に見つけることができるでしょう。</p><p><img src=https://miro.medium.com/max/4800/1*cALhZ5hA_MNesjhkiZkN2w.png alt="Our application will implement blue/green deployments using the builtin features of Container Apps"></p><h2 id=アプリの概要>アプリの概要</h2><p>私は、素因数分解の計算を分散して実装するデモアプリケーションを作成しました。このアプリケーションは、キャッシングとサービス間の呼び出しにDaprを利用し、バックエンドとフロントエンドのサービスで構成されています。このアプリケーションのコード、スクリプト、セットアップ方法の説明は、<a href=https://github.com/denniszielke/blue-green-with-containerapps>Dennis ZielkeのGitHubリポジトリ</a>にあります。このリポジトリをフォークして、ご自身のAzure環境でシナリオを試してみることをお勧めします。</p><p><img src=https://miro.medium.com/max/1400/1*uy31KJ_Bc7DVu2wFmb13tQ.png alt="The builtin features of Dapr, Keda and Envoy simplify a lot of the operational concerns during the upgrades."></p><p>以下で、その仕組みをご紹介したいと思います。</p><h2 id=パイプラインの構成とインフラの構築>パイプラインの構成とインフラの構築</h2><p>まず最初にしなければならないのは、GitHub Actionsのパイプラインを設定するために、リポジトリをforkすることです。GitHubとAzureが信頼関係の機能をアップグレードしたことをご存知でしょうか。GitHub リポジトリのパイプラインに GitHubのトークンとAzure ADのトークンを交換する権限を与えれば、クライアントのSecretを共有しなくても Azureリソースを操作できるようになるということです。これは大きな進歩です。</p><p>私のリポジトリにあるパイプラインは、アプリの登録を作成し、Azureサブスクリプション内の専用リソースグループに<code>Contributor</code>パーミッションを付与していることを前提としています。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># デプロイメント名</span>
DEPLOYMENT_NAME<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dzca11cgithub&#34;</span> 
<span style=color:#75715e># リソースグループ名</span>
RESOURCE_GROUP<span style=color:#f92672>=</span>$DEPLOYMENT_NAME 
<span style=color:#75715e># Azure リージョン名(japaneastは未対応)</span>
LOCATION<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;eastus&#34;</span> 

<span style=color:#75715e># AzureのサブスクリプションID</span>
AZURE_SUBSCRIPTION_ID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>az account show --query id -o tsv<span style=color:#66d9ef>)</span> 

<span style=color:#75715e># GitHubのユーザ名</span>
GHUSER<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;denniszielke&#34;</span>
<span style=color:#75715e># GitHubのリポジトリ名</span>
GHREPO<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;blue-green-with-containerapps&#34;</span>

<span style=color:#75715e># テナントID</span>
AZURE_TENANT_ID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>az account show --query tenantId -o tsv<span style=color:#66d9ef>)</span>

<span style=color:#75715e># リソースグループの作成</span>
az group create -n $RESOURCE_GROUP -l $LOCATION -o none

<span style=color:#75715e># spの作成</span>
AZURE_CLIENTID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>az ad sp create-for-rbac --name <span style=color:#e6db74>&#34;</span>$DEPLOYMENT_NAME<span style=color:#e6db74>&#34;</span> --role contributor --scopes <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>/subscriptions/</span>$AZURE_SUBSCRIPTION_ID<span style=color:#e6db74>/resourceGroups/</span>$RESOURCE_GROUP<span style=color:#e6db74>&#34;</span> -o json | jq -r <span style=color:#e6db74>&#39;.appId&#39;</span><span style=color:#66d9ef>)</span>
</code></pre></div><p>ここで、GitHub リポジトリと Azure AD テナントとのフェデレーションを許可する必要があります。Azure Portalを開き「Azure Active Directory」→「App registrations」→「上記で設定した<code>DEPLOYMENT_NAME</code>」→「Certificates & secrets」→「Federated credentials」に移動し、<code>main</code>ブランチでトリガーされるパイプラインが、アプリ登録のセキュリティコンテキスト内でトークンを交換することを許可します。</p><p><img src=https://miro.medium.com/max/4800/1*Sz55_2DTtNcNRLJhU74j5Q.png alt="Make sure that your repo and branch can exchange tokens"></p><p>次に、以下のシークレットをgithubリポジトリに追加する必要があります。Azure ADとのフェデレーションの機能によって「Client Secret」が不要になったことに注目しましょう。</p><ul><li>AZURE_CLIENT_ID</li><li>AZURE_SUBSCRIPTION_ID</li><li>AZURE_TENANT_ID</li><li>RESOURCE_GROUP</li></ul><p><img src=https://miro.medium.com/max/1006/1*60UiIM4a60njEWnkp6BjVQ.png alt="Create these GitHub Secrets in your forked repo"></p><p>これで、GitHub パイプラインがどこにデプロイすればよいかがわかるようになりました。</p><p>注意しておきたいのは、Pipeleneで実装されたトークン交換の実行には1分かかることと、現時点ではazure cliのベータ版が必要なことです。
これが完了したら、GitHub Actuionsの<code>deploy-infrastructure</code> パイプラインを手動で起動して、Container Appsを含むAzureリソースを作成できます。</p><p><img src=https://miro.medium.com/max/1400/1*hs4fFWJDnhjb8jt8kPF3DA.png alt="Use the pipeline to create your azure resources"></p><h2 id=サンプルアプリのデプロイ>サンプルアプリのデプロイ</h2><p>次に、ソースコードを変更するか、<code>deploy-full-blue-green</code> パイプラインを手動でトリガーすることで、アプリケーションの最初のデプロイを実行します。</p><p>これでアプリケーションの<code>blue</code>リビジョンが動作するようになりました。ここで、デプロイメントプロセスを構成する300 行のシェルスクリプトを見てみましょう。もしGitHub パイプラインを使いたくない場合は、<code>deploy.sh</code> スクリプトに、次のパラメータを指定してローカルマシンから同じ処理を実行できます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>bash ./deploy.sh $RESOURCE_GROUP $IMAGE_TAG $CONTAINER_REPOSITORY
</code></pre></div><p>ブルーグリーンデプロイメントの原則とは、以前のリビジョン（このリビジョンを<code>bule</code>とする）を置き換える代わりに、新しいバージョン（このリビジョンを<code>green</code>とする）を既存のバージョンの隣に立ち上げるものの、実際のユーザーにはすぐに公開しないことを意味しています。<code>green</code>が正常に動作することを検証できた場合、ダウンタイムなしにルーティング設定を変更して、このリビジョンを正常系(本番系)に昇格させます。もし<code>green</code>リビジョンで何か問題が発生した場合、ユーザーは中断に気づくことなく、元に戻すことができます。</p><p>Azure Container Appsをつかうと、複数のリビジョンを同時にデプロイすることができ、どのリビジョンがどの相対的な量のトラフィックを受信しているかをAPI経由で制御できるため、多くのケースで必要になる非機能要件はすでにプラットフォームの一部となっています。</p><p>最初のデプロイメントでは、リビジョンモードが<code>multiple</code>に設定されていることを確認する必要があります。これは、アクティブでトラフィックを受信しているリビジョンの数を制御できることを意味します。いくつかのシナリオでは、プラットフォームが異なるリビジョン間を自動的に切り替えることに意味がありますが、私たちは本番トラフィックをさらに細かく制御したいと考えています。複数のリビジョンを使用すると、各リビジョン専用の FQDNが得られ、お客様に気づかれることなく新しいリビジョンのウォームアップと検証を非公開で行うことができます。</p><p><img src=https://miro.medium.com/max/1350/1*UAfklqQNWfPGVI6FWz8uyw.png alt="The revision mode gives us manual control over traffic splits and routing"></p><p>もしリビジョンが期待通りに動作していないと判断した場合、リビジョンを無効にして、次のリリースで修正できます。コンテナアプリごとに非常に多くのリビジョンを作成できるため、すべてのデプロイでこの概念を使用することはまったく問題ありません。</p><p><img src=https://miro.medium.com/max/1400/1*wwR8Atul6YLZp7375NC1DA.png alt></p><p>新しいバージョンを検証した後は、本番用のトラフィックとして、新しい<code>green</code>向けのトラフィックを徐々に増やしていくことができます。</p><p><img src=https://miro.medium.com/max/1400/1*0CmJ6QixYdy-SVSkGaasnQ.png alt="While we are running a traffic split of 50/50 our users will be seeing both versions in production"></p><p>シェルスクリプトをご覧になったことがあると思いますが、アクティブなリビジョンが2つ以上ないことや、バックエンドサービスにパブリックIPを使用していることなど、いくつかのポイントがあります。通常バックエンドサービスを外部公開する必要はありませんが、GitHub のパイプラインからVNET へのプライベートなアクセスはできないので、今回はデモをスムーズに行うためにこのような構成にしています。</p><p>また、Container Appsには、スケーリングルールを使ってアプリのレプリカを適切な数にする機能があります。この例では、各レプリカが1秒間に10件以上の同時リクエストを受けないようにします。またトラフィックが全く無い場合は、レプリカの数を0にしてコストを削減することもできますが、ダウンタイムなしにロールバックする機能に影響が出るため、今回は1つのレプリカにしかスケールダウンできないようにしています。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>[{
  <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;httpscalingrule&#34;</span>,
  <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;http&#34;</span>,
  <span style=color:#f92672>&#34;metadata&#34;</span>: {
     <span style=color:#f92672>&#34;concurrentRequests&#34;</span>: <span style=color:#e6db74>&#34;10&#34;</span>
  }
}]
</code></pre></div><p>フロントエンドとバックエンドのコンテナどちらも、プラットフォームの一部であるDaprサイドカーを利用しています。主な利点は、コードをAzure SDKに依存させることなく、Azure Redis・Application Insights・KeyVaultなどのAzureマネージドサービスを利用できることです。これにより、Azureを使わずにローカルでアプリケーションをテストしたり、他のクラウドやサービスでコンテナを実行したりすることが容易になります。フロントエンドやバックエンドとAzureプラットフォームの間のすべてのやり取りは、Daprサイドカーを介して行われます。私たちがすべきことは、Daprを有効にし、URLがDaprサイドカーのポート(今回は3500)を参照していることを確認することだけです。</p><p><img src=https://miro.medium.com/max/1400/1*6SGs0f2I4RoGoBUkNhZONw.png alt="Enabling Dapr brings a lot of benefits to our scenario"></p><p>また、Daprサイドカーを使用して、フロントエンドとバックエンド間のサービス間通信を実装しています。両方のアプリには専用の<code>dapr-app-id</code>があり、これを使ってフロントエンドコンテナからバックエンドAPIに次のURLを使って呼び出すことができます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>http://localhost:3500/v1.0/invoke/js-calc-backend/method/DoSomeThing
</code></pre></div><p>Daprサイドカーを有効にすることによるもう一つの素晴らしい効果は、各サービスとDaprが通信しているazureリソースとの間のすべてについて、分散型トレース情報を受け取ることができることにあります。</p><p><img src=https://miro.medium.com/max/1400/1*1YEjmoaYkDkBJwk7j5L2Hg.png alt="The application maps show the interactions between all dapr enabled services and resources"></p><p>また、デプロイメントスクリプトの一番最後に、デプロイが成功するたびにリリースアノテーションを作成し、Application Insightsダッシュボードでパフォーマンス指標やエラーデータを簡単に比較できるようにしています。</p><p><img src=https://miro.medium.com/max/1400/1*Yoh8dA02JF7VQ0rrFrROsQ.png alt="The marker documents each release and allows us to compare performance and errors between releases"></p><h2 id=まとめ>まとめ</h2><p>このサンプルは、新しいAzure Container Appsが、比較的シンプルなコンセプトに基づいた非常に強力なプラットフォームであることを示していると思います。もしあなたが、ダウンタイムなしで継続的にアプリケーションをアップグレードする必要があるものの、Kubernetes上で同様のことを実現するためのインフラ管理や学習コストなどで躊躇していたケースでは、とてもエキサイティングな選択肢の1つになるかもしれません。</p><p>改善のためのフィードバックやレポへのプルリクエストをお待ちしています。</p><p>以上</p></div></main></body></html>