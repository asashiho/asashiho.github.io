<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dapr on ASA Blog</title><link>https://asashiho.github.io/categories/dapr/</link><description>Recent content in dapr on ASA Blog</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>Your Copyright</copyright><lastBuildDate>Tue, 28 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://asashiho.github.io/categories/dapr/index.xml" rel="self" type="application/rss+xml"/><item><title>Daprによる分散アプリケーションのリトライ処理について</title><link>https://asashiho.github.io/dapr-resiliency/dapr-resiliency/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://asashiho.github.io/dapr-resiliency/dapr-resiliency/</guid><description>お仕事でプリセールスをして極めてミッションクリティカルな業務システムに携わっているため、お客様やSIパートナー様といっしょに「絶対に止まらないシステム」について検討することが多くあります。インフラの可用性については、すでに多く議論されているのですが、いわゆるクラウドネイティブアプリケーションの場合は、分散システムを考慮したアプリケーションアーキテクチャについて検討する必要があります。
これはクラウドに限った話ではないのですが、分散システムでは一過性の障害をなくすことはできません。なので分散システムにおいて「SLAを100%にするぞ！」ではなく、「障害が起こっても素早く回復させる」「一部の障害を系全体に伝播させない」というようなアプローチのほうが筋が良いといえるでしょう。
参考: Azure で回復性があるアプリケーションを実現するためのエラー処理
クラウドネイティブなアプリケーションは、クラウドベンダーが提供するサービス/ユーザが個別で開発するシステムサービスを組み合わせて開発することで、クラウドの持ち味であるアジリティやスケーラビリティを活かすことができますが、次のような分散システムが本質的に持つ技術的課題もあります。
サービス間の呼び出し サービス間での状態共有 システムの監視 シークレットの管理 障害部分のみ切り離してサービスを継続させる Microsoftは、クラウドネイティブなシステムにおいて分散処理を実装するランタイムである「Dapr(Distributed Application Runtime)」をオープンソースとして開発し、CNCFに寄贈しました。このDaprは上記の課題をアプリケーションランタイムで解決しようというアプローチをとっています。
Daprが提供する機能 Daprはライブラリのようにアプリケーションに組み込むのではなく、Dapr自身がコンテナあるいはプロセスとして実行され、それをサービスからHTTP/gRPC API経由で呼び出して利用するビルディングブロックとして実現されているのが特徴です。
Service Invocation リトライ、分散トレースなどのマイクロサービスに不可欠な機能をサポートするサービス間通信機能
State management キー/バリュー形式の状態管理 状態を保管するコンポーネントとしてRedis/CosmosDB/MySQLなどがある
Publish &amp;amp; subscribe messaging publish/Subscribe形式のメッセージング機能
Bindings データベースやキュー、ファイルシステムなどにイベントを送受信する機能
Actors アクターズパターンに関連する機能
Observability 各種メトリックス、ログ、トレース機能
Secrets management 秘匿情報の管理機能 AWS Secrets Manager/GCP Secrets Manager/Azure Key Vaultなどと連携可能
Configuration アプリケーションの構成管理
Daprのアーキテクチャ Daprは、HTTPおよびgRPC APIを、コンテナーまたはプロセスとしてサイドカーアーキテクチャとして公開し、アプリケーションコードにDaprランタイムコードを含める必要はありません。</description></item><item><title>Azure Container Apps/GitHub Actionsを使ったコンテナアプリのブルーグリーンデプロイメント</title><link>https://asashiho.github.io/containerapps/containerapps/</link><pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate><guid>https://asashiho.github.io/containerapps/containerapps/</guid><description>このブログエントリは、MicrosoftのGlobal Blackbelt for cloud native applicationsであるDennis ZielkeのブログImplementing continuous blue/green deployments on Azure Container Apps by using GitHub Actionsについて、Dennisの承諾を得て日本語に翻訳しています。
Microsoft Azureは、GitHub ActionsやAzure Monitorに加えて、新しいServerless Application Platformである「Container Apps」をリリースしました。そこで私は、KubernetesとAzure上でBlue/Greenの継続的デプロイを行うというシナリオを再検討し、新しい技術スタックを使ってそれを実装する方法を紹介します。もし、Container Appsを使う機会がないけれと自分で試してみたいと思っているのであれば、お勧めの記事です。
ここでは、以下の機能を試します:
コンテナのランタイムとしてのAzure Container Apps クラスタ内でのサービス間の呼び出しを行うDapr トラフィックに応じてコンテナを自動的にスケーリングするKeda リビジョン間のトラフィック分割を実装するためのEnvoy Application Insightsでの分散トレーシング Azure ADのFederated Service Identityに対応したGitHub Actions システムの概要 この記事の目的は、ブルー/グリーンデプロイメントを実施し、GitHub Actionsを使用した場合に、Azure Container Appsでのダウンタイムのない継続的デプロイメントがどれだけ簡単かを確認することです。もちろん、他のCI/CDツールチェーンを使用することもできますが、ロジックのほとんどがシェルスクリプトで実装されているため、プロセスを移行する方法を簡単に見つけることができるでしょう。
アプリの概要 私は、素因数分解の計算を分散して実装するデモアプリケーションを作成しました。このアプリケーションは、キャッシングとサービス間の呼び出しにDaprを利用し、バックエンドとフロントエンドのサービスで構成されています。このアプリケーションのコード、スクリプト、セットアップ方法の説明は、Dennis ZielkeのGitHubリポジトリにあります。このリポジトリをフォークして、ご自身のAzure環境でシナリオを試してみることをお勧めします。
以下で、その仕組みをご紹介したいと思います。
パイプラインの構成とインフラの構築 まず最初にしなければならないのは、GitHub Actionsのパイプラインを設定するために、リポジトリをforkすることです。GitHubとAzureが信頼関係の機能をアップグレードしたことをご存知でしょうか。GitHub リポジトリのパイプラインに GitHubのトークンとAzure ADのトークンを交換する権限を与えれば、クライアントのSecretを共有しなくても Azureリソースを操作できるようになるということです。これは大きな進歩です。
私のリポジトリにあるパイプラインは、アプリの登録を作成し、Azureサブスクリプション内の専用リソースグループにContributorパーミッションを付与していることを前提としています。
# デプロイメント名 DEPLOYMENT_NAME=&amp;#34;dzca11cgithub&amp;#34; # リソースグループ名 RESOURCE_GROUP=$DEPLOYMENT_NAME # Azure リージョン名(japaneastは未対応) LOCATION=&amp;#34;eastus&amp;#34; # AzureのサブスクリプションID AZURE_SUBSCRIPTION_ID=$(az account show --query id -o tsv) # GitHubのユーザ名 GHUSER=&amp;#34;denniszielke&amp;#34; # GitHubのリポジトリ名 GHREPO=&amp;#34;blue-green-with-containerapps&amp;#34; # テナントID AZURE_TENANT_ID=$(az account show --query tenantId -o tsv) # リソースグループの作成 az group create -n $RESOURCE_GROUP -l $LOCATION -o none # spの作成 AZURE_CLIENTID=$(az ad sp create-for-rbac --name &amp;#34;$DEPLOYMENT_NAME&amp;#34; --role contributor --scopes &amp;#34;/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP&amp;#34; -o json | jq -r &amp;#39;.</description></item></channel></rss>